% 一
s=[];a=-1;b=1;N=100000;
for k=1:6
    x=rand(N,2);
    s=[s sum(exp(-((-1+2*x(:,1))).^2)-x(:,2)>=0)/N];
end
s=s*(b-a)*1
% 二
N=1000000;
for k=1:6 
    x=unifrnd(-1,1,N,1);  % 产生区间[-1,1]上的N个均匀随机数
    y=unifrnd(-1,1,N,1);  % 产生区间[-1,1]上的N个均匀随机数
    z=unifrnd(0,2,N,1);  % 产生区间[0,2]上的N个均匀随机数
    Z=1+sqrt(1-x.^2-y.^2)-sqrt(x.^2+y.^2);
    p(k)=8*sum(z<=Z)/N;
end 
p
% 三
rand('state',20)  % 设置随机数状态
for k=1:6
    j=1;N=1000;  % j为计数器，N为模拟次数
    while j<=N
        r=rand(1,4);  % 生成4个[0,1]区间上的均匀分布的随机数
        if (log(4)+r(1)/4+r(2)/4+r(3)/4-3/4)/(log(4)-3/8)>=log(4)*r(4)  % 有利随机数密度
            x(j)=r(1);y(j)=r(2);z(j)=r(3);
            j=j+1;  % 计数器加1
        end
    end
    I(k)=(1/N)*sum(log(1+x+y+z)./((log(4)+...
        x/4+y/4+z/4-3/4)/(log(4)-3/8)));  % 计算三重积分值
end
I  % 显示计算结果
